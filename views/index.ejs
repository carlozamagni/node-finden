<div id="map" style="top:0; bottom:0; left:0; right:0; position:absolute;"></div>

<div id="settings"> 

  <div id="toggle-edit">Toggle</div>
  <div id="save-region">Save</div>
  <div id="log"></div>

</div>

<script src="Leaflet/dist/leaflet.js"></script>

<script type="text/javascript"> 
  
  /** Converts numeric degrees to radians */
  if (typeof(Number.prototype.toRad) === "undefined") {
    Number.prototype.toRad = function() {
      return this * Math.PI / 180;
    }
  }
  
  /** Converts numeric degrees to radians */
  if (typeof(Number.prototype.toDeg) === "undefined") {
    Number.prototype.toDeg = function() {
      var d = 360/(2*Math.PI);
      return this * d;
    }
  }
  
  var io = io.connect();
  
  $(function() {
    var cloudmadeUrl = 'http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/997/256/{z}/{x}/{y}.png', 
    cloudmadeAttribution = '',
    cloudmade = new L.TileLayer(cloudmadeUrl, {
      maxZoom: 18, 
      attribution: cloudmadeAttribution
    }),
    calculate = {
      distance: function( point1, point2 ){
        var lat1 = point1[0], lat2 = point2[0], lon1 = point1[1], lon2 = point2[1],
            R = 6371, 
            dLat = (lat2-lat1).toRad(), dLon = (lon2-lon1).toRad(),
            lat1 = lat1.toRad(), lat2 = lat2.toRad(),
            a = Math.sin(dLat/2) * Math.sin(dLat/2) + 
                Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2),
            c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)),
            d = R * c;
        return d
      },
      pointInPolygon: function(o,lat,lon){
        var inPoly=false;
        $.each(o, function(k, p) {
          var i,points = p._latlngs,j=points.length-1
          for (i=0; i<points.length; i++) {
            if (points[i].lng<lon && points[j].lng>=lon || points[j].lng<lon && points[i].lng>=lon){
              if (points[i].lat + (lon-points[i].lng)/(points[j].lng-points[i].lng)*(points[j].lat - points[i].lat)<lat){
                inPoly=!inPoly; 
              }
            }
            j=i; 
          }
        })
        return inPoly;
      }
    },
    user = {
      _e: false, _h: [], _p:[],
      isTraveling: function(){
       return this._h.length > 0 ? true : false
      },
      toggleEdit: function(){
        this._e = !this._e
      },
      canEdit: function(){
        return this._e
      },
      hasPolygons: function(){
        return this._p.length > 0 ? true : false
      },
      getPolygons: function(){
        return this._p
      },
      record: function( p ){
        this._h.push( p )
      },
      clearHistory: function(){
        this._h = []
      },
      getHistory: function(){
        return this._h
      },
      getHistoryByIndex: function(o){
        return this._h[o] ? this._h[o] : null
      },
      getHistoryByOffset: function( offset ){
        return this._h[this._h.length - offset] ? this._h[this._h.length - offset] : null
      },
      storePolygon: function(o){
        this._p.push(o)
        console.log(this._p)
      },
      log: function( d ){
        $('#log').text( d )
      }
    },
    map = new L.Map('map'),
    pos = new L.LatLng(40.770012,-73.973694);
    
		map.setView(pos, 13).addLayer(cloudmade);
		
    map.spawnCircle = function( lat, lng, r ){
      var latlng = new L.LatLng(lat, lng), 
          circle = new L.CircleMarker(latlng, {
            stroke: true,
            radius: r
          });
      this.addLayer( circle );
      return circle
    }
    
    map.addPolyline = function( s, e ){
      var polyline = new L.Polyline([new L.LatLng(s.lat,s.lng),new L.LatLng(e.lat, e.lng)],{color: 'blue'});
      this.addLayer(polyline)
      return polyline
    }
    
    map.addPolygon = function( p ){
      var polygon = new L.Polygon(p, {color: 'blue'} );
      this.addLayer(polygon)
      return polygon
    }
    
    map.on('click', function (e) {
      if(user.canEdit()){
        var circle = this.spawnCircle(e.latlng.lat, e.latlng.lng, 10)
        if(user.isTraveling()){
          user.record({
            "lat" : e.latlng.lat, 
            "lng" : e.latlng.lng,
            "circle" : circle 
          })
          var polyline = this.addPolyline( user.getHistoryByOffset(2), user.getHistoryByOffset(1) )
          user.getHistoryByOffset(1).polyline = polyline
        }else{
          user.record({
            "lat" : e.latlng.lat, 
            "lng" : e.latlng.lng,
            "circle" : circle 
          })
        }
      }
    });
    
    /* connect to the server */
    io.on('mapTweet', function ( tweet ){
      
      if( tweet.geo ){
      
        if(user.hasPolygons()){
          var isValid = calculate.pointInPolygon(user.getPolygons(), tweet.geo.coordinates[0], tweet.geo.coordinates[1])

          if(isValid){
            var pos = new L.LatLng(tweet.geo.coordinates[0],tweet.geo.coordinates[1]), markerLocation = pos,
            marker = new L.Marker(markerLocation);
            map.addLayer(marker);
          }else{
          
            console.log('not valid')
          
          }
          
        }

      }
      
    });
    
    //click handlers
    $('#toggle-edit').click(function(){
      user.toggleEdit()
    })
    
    $('#save-region').click(function(){
      var history = user.getHistory(),
          polyPoints = [];
      $.each(history, function(i, p) {
      
        polyPoints.push(new L.LatLng(p.lat, p.lng)) 
        
        if( i >= history.length -1 ){
          var polygon = map.addPolygon(polyPoints)
          user.clearHistory()
          user.storePolygon( polygon )
        }
      });
    })
    
  });
</script>  